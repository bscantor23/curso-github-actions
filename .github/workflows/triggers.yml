name: Production CI/CD
on:
  pull_request:
    types:
      - closed
    branches:
      - main
  push:
    tags:
      - 'v*'
    paths:
      - 'packages/**'
      - '.github/workflows/ci-cd-production.yml'
  workflow_dispatch:
    inputs:
      job:
        description: 'The name of the job to run'
        required: true
        default: 'all'

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}

jobs:
  create-tag-release:
    if: (startsWith(github.event.pull_request.head.ref, 'feature') || startsWith(github.event.pull_request.head.ref, 'hotfix') || startsWith(github.event.pull_request.head.ref, 'bugfix')) && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: read
    outputs:
      release_tag: ${{ steps.create_tag_patch.outputs.new_tag || steps.create_tag_major.outputs.new_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: '0'

      - name: Create tag version feature
        if: ${{ startsWith(github.head_ref, 'feature') }}
        id: create_tag_major
        uses: anothrNick/github-tag-action@v1
        env:
          WITH_V: true
          VERBOSE: true
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BRANCHES: feature/*

      - name: Create tag version patch
        if: ${{ startsWith(github.head_ref, 'hotfix') || startsWith(github.head_ref, 'bugfix') }}
        id: create_tag_patch
        uses: anothrNick/github-tag-action@v1
        env:
          WITH_V: true
          DEFAULT_BUMP: patch
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BRANCHES: hotfix/*, bugfix/*

      - name: Set PR title as branch name
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const branchName = context.payload.pull_request.head.ref;

            if (context.payload.pull_request.title !== branchName) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                title: branchName
              });
              core.info(`PR title updated to branch name: ${branchName}`);
            }

      - name: Check PR number
        id: check_pr_number
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = context.payload.pull_request?.number || Number(process.env.PR_NUMBER);
            if (!prNumber) {
              core.setFailed('No se pudo determinar el número de PR.');
              return;
            }
            core.notice(`PR detectado: #${prNumber}`);
            core.setOutput('prNumber', prNumber.toString());

      - name: Check PR data
        id: check_pr_data
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number('${{ steps.check_pr_number.outputs.prNumber }}');
            let prData;
            try {
              const resp = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              prData = resp.data;
            } catch (e) {
              core.setFailed('No se pudo obtener el PR #' + prNumber + ': ' + e.message);
              return;
            }

            const prBody = (prData.body || '').trim();
            if (!prBody) {
              core.setFailed(`El PR #${prData.number} no tiene un mensaje para enlazar en el release (descríbelo).`);
              return;
            }

            core.setOutput('baseRef', prData.base.sha);
            core.setOutput('headRef', prData.head.sha);
            core.setOutput('pullNumber', prData.number.toString());
            core.setOutput('prBody', prBody);
            core.setOutput('user', prData.user.login);
            core.setOutput('title', prData.title);

      - name: Check PR issues
        id: check_pr_issues
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number('${{ steps.check_pr_number.outputs.prNumber }}');

            async function findLinkedIssues(owner, repo, pr) {
              const issuesMap = new Map();
              // A. closingIssuesReferences (palabras clave en body/commits)
              const q1 = `query($owner:String!,$repo:String!,$pr:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$pr){ closingIssuesReferences(first:20){ nodes { number title } } }
                }
              }`;
              try {
                const r1 = await github.graphql(q1,{owner,repo,pr});
                (r1.repository.pullRequest.closingIssuesReferences.nodes||[])
                  .forEach(i=> issuesMap.set(i.number, i));
              } catch (e) {
                core.warning('Fallo closingIssuesReferences: ' + e.message);
              }
              // B. CONNECTED_EVENT (enlace manual)
              const q2 = `query($owner:String!,$repo:String!,$pr:Int!,$max:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$pr){
                    timelineItems(first:$max,itemTypes:[CONNECTED_EVENT]){ nodes { ... on ConnectedEvent { subject { __typename ... on Issue { number title } } } } }
                  }
                }
              }`;
              try {
                const r2 = await github.graphql(q2,{owner,repo,pr,max:30});
                (r2.repository.pullRequest.timelineItems.nodes||[])
                  .map(n=> n.subject)
                  .filter(s=> s && s.__typename==='Issue')
                  .forEach(i=> issuesMap.set(i.number, i));
              } catch (e) {
                core.warning('Fallo CONNECTED_EVENT: ' + e.message);
              }
              return Array.from(issuesMap.values());
            }
            const issues = await findLinkedIssues(owner, repo, prNumber);
            if (!issues || issues.length === 0) {
              core.setFailed('No se detectaron issues vinculados. Usa keywords (resolves/fixes/closes #N) o "Link an issue".');
              return;
            }
            // Regla de negocio: límite máximo
            const MAX_ISSUES = 1;
            if (issues.length > MAX_ISSUES) {
              core.setFailed(`Demasiados issues detectados (${issues.length}).`);
              return;
            }
            core.setOutput('issue', JSON.stringify(issues[0]));

      - name: Check PR commits
        id: check_pr_commits
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const baseRef = '${{ steps.check_pr_data.outputs.baseRef }}';
            const headRef = '${{ steps.check_pr_data.outputs.headRef }}';
            const pullNumber = Number('${{ steps.check_pr_data.outputs.pullNumber }}');

            let commits = [];
            try {
              const compare = await github.rest.repos.compareCommits({ owner, repo, base: baseRef, head: headRef });
              commits = compare.data.commits || [];
            } catch (e) {
              core.warning('Fallo compareCommits, fallback a listCommits del PR: ' + e.message);
              commits = await github.paginate(
                github.rest.pulls.listCommits,
                { owner, repo, pull_number: pullNumber, per_page: 100 }
              );
            }
            const commitLines = commits.map(c => {
              const first = c.commit.message.split('\n')[0];
              const url = `https://github.com/${owner}/${repo}/commit/${c.sha}`;
              return `- Commit [${c.sha.slice(0,7)}](${url}): ${first}`;
            });
            core.setOutput('commits', JSON.stringify(commitLines));

      - name: Build release summary
        id: release_summary
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prBody = '${{ steps.check_pr_data.outputs.prBody }}';
            const issue = JSON.parse('${{ steps.check_pr_issues.outputs.issue }}');
            const commits = JSON.parse('${{ steps.check_pr_commits.outputs.commits }}');


            console.log(prBody);
            console.log(issue);
            console.log(commits);

            const tag = '${{ steps.create_tag_patch.outputs.new_tag || steps.create_tag_major.outputs.new_tag }}';
            if (!tag) {
              core.setFailed('Tag no disponible aún.');
              return;
            }

            let summary = `# Release ${tag} 🚀\n\n`;
            summary += `### Author 👤: @${{ steps.check_pr_data.outputs.user }}\n\n`;
            summary += `### Description 💬: \n\n`;
            summary += prBody + '\n\n';
            summary += '---\n';
            summary += `### Pull Request 🔀:\n- [PR #${{ steps.check_pr_data.outputs.pullNumber }}: ${{ steps.check_pr_data.outputs.title }}](https://github.com/${{ github.repository }}/pull/${{ steps.check_pr_data.outputs.pullNumber }})\n\n`;
            summary += `### Issue 🐛:\n- [Issue #${issue.number}: ${issue.title}](https://github.com/${{ github.repository }}/issues/${issue.number})\n\n`;
            summary += `### Commits (${commits.length}) 📦:\n`;
            summary += commits.length ? commits.join('\n') + '\n\n' : '- (Ninguno)\n\n';
            summary += 'Generado automáticamente 🤖.\n';

            const summaryHtml = await github.rest.markdown.render({
              text: summary,
              mode: "gfm"
            });

            console.log(summaryHtml.data);

            core.setOutput('release_body', summary);
            core.setOutput('release_body_html', summaryHtml.data);

      - name: Create GitHub release hotfix
        if: ${{ startsWith(github.head_ref, 'hotfix') || startsWith(github.head_ref, 'feature') || startsWith(github.head_ref, 'bugfix') }}
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create_tag_patch.outputs.new_tag || steps.create_tag_major.outputs.new_tag }}
          release_name: ${{ steps.create_tag_patch.outputs.new_tag || steps.create_tag_major.outputs.new_tag }}
          body: ${{ steps.release_summary.outputs.release_body }}
          draft: true
          prerelease: false

      - name: Publish release
        uses: StuYarrow/publish-release@v1.1.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          id: ${{ steps.create_release.outputs.id }}

      - name: Send email using AWS SES
        uses: dsfx3d/action-aws-ses@v1
        with:
          to: 'desarrollo@nominasaps.com'
          from: 'no-reply@nominasaps.com'
          subject: 'Desarrollo | Salida a producción APS | ${{ steps.create_tag_patch.outputs.new_tag || steps.create_tag_major.outputs.new_tag }}'
          body: ${{ steps.release_summary.outputs.release_body }}
          body_html: '${{ steps.release_summary.outputs.release_body_html }}'
