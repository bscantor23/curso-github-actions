name: Pull Request Main CI/CD

on:
  pull_request:
    branches: [main]
    types: [opened, edited, synchronize]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Detect PR number
        id: detect_pr
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = context.payload.pull_request?.number || Number(process.env.PR_NUMBER);
            if (!prNumber) {
              core.setFailed('No se pudo determinar el número de PR.');
              return;
            }
            core.notice(`PR detectado: #${prNumber}`);
            core.setOutput('prNumber', prNumber.toString());
      - name: Check PR description
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number('${{ steps.detect_pr.outputs.prNumber }}');

            let prData;
            try {
              const resp = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              prData = resp.data;
            } catch (e) {
              core.setFailed('No se pudo obtener el PR #' + prNumber + ': ' + e.message);
              return;
            }

            //3. Obtener el mensaje del PR
            const prBody = (prData.body || '').trim();
            if (!prBody) {
              core.setFailed(`El PR #${prData.number} no tiene un mensaje para enlazar en el release (descríbelo).`);
              return;
            }
      - name: Check linked issues
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number('${{ steps.detect_pr.outputs.prNumber }}');

            async function findLinkedIssues(owner, repo, pr) {
              const issuesMap = new Map();
              // A. closingIssuesReferences (palabras clave en body/commits)
              const q1 = `query($owner:String!,$repo:String!,$pr:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$pr){ closingIssuesReferences(first:20){ nodes { number title } } }
                }
              }`;
              try {
                const r1 = await github.graphql(q1,{owner,repo,pr});
                (r1.repository.pullRequest.closingIssuesReferences.nodes||[])
                  .forEach(i=> issuesMap.set(i.number, i));
              } catch (e) {
                core.warning('Fallo closingIssuesReferences: ' + e.message);
              }
              // B. CONNECTED_EVENT (enlace manual)
              const q2 = `query($owner:String!,$repo:String!,$pr:Int!,$max:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$pr){
                    timelineItems(first:$max,itemTypes:[CONNECTED_EVENT]){ nodes { ... on ConnectedEvent { subject { __typename ... on Issue { number title } } } } }
                  }
                }
              }`;
              try {
                const r2 = await github.graphql(q2,{owner,repo,pr,max:30});
                (r2.repository.pullRequest.timelineItems.nodes||[])
                  .map(n=> n.subject)
                  .filter(s=> s && s.__typename==='Issue')
                  .forEach(i=> issuesMap.set(i.number, i));
              } catch (e) {
                core.warning('Fallo CONNECTED_EVENT: ' + e.message);
              }
              return Array.from(issuesMap.values());
            }
            const issues = await findLinkedIssues(owner, repo, prNumber);
            if (!issues || issues.length === 0) {
              core.setFailed('No se detectaron issues vinculados. Usa keywords (resolves/fixes/closes #N) o "Link an issue".');
              return;
            }
            // Regla de negocio: límite máximo
            const MAX_ISSUES = 1;
            if (issues.length > MAX_ISSUES) {
              core.setFailed(`Demasiados issues detectados (${issues.length}).`);
              return;
            }
